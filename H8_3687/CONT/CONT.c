/***********************************************************************/
/*                                                                     */
/*  FILE        :CONT.c                                                */
/*  DATE        :Tue, Jun 28, 2016                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8/3687                                               */
/*                                                                     */
/*  This file is generated by WakuwakuP.                               */
/*                                                                     */
/*  github URL: https://github.com/WakuwakuP/Kadai_no_Hakaba           */
/*                                                                     */
/***********************************************************************/

// 設定
//	|-------------------------------------------|
//	|一回転			: 48.69468613				|
//	|1パルス		: 0.08115781022				|
//	|50mm			: 616パルス					|
//	|J7				: モーター(PWM)				|
//	|P50			: エンコーダA相				|
//	|P51			: エンコーダB相				|
//	|P52			: フォトマイクロセンサ1		|
//	|P53			: フォトマイクロセンサ2		|
//	|-------------------------------------------|


#include "iodefine.h"
#include "lcd_func.h"
#include <machine.h>

void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

int pulse = 0;
int mode = 0;

void WKP_func(void);						// 外部割込み用関数

void MoveStageR(void);						// ステージ右(-)移動用関数
void MoveStageL(void);						// ステージ左(+)移動用関数
void MoveStagePlus(int);					// 数値指定ステージ移動関数

void wait(void);							// チャタリング防止用関数

void main(void){
	lcd_init();								// LCD初期化
	IO.PCR5			= 0xF0;					// LCD使用。0~3まで入力使用
	IO.PUCR5.BYTE	= 0xFC;					// プルアップ
	IO.PMR5.BYTE	= 0x0D;					// 割り込み許可ポート設定
	IEGR2.BYTE		= 0x00;					// WKP立ち下がりエッジに設定
	IWPR.BYTE		= 0x00;					// WKP割り込みフラグクリア

	IO.PMR1.BYTE	= 0xF0;					// SW割り込みモード設定
	IEGR1.BYTE		= 0x70;					// SW立ち上がりエッジに設定
	IRR1.BYTE		= 0x30;					// SW割り込みフラグクリア

	TZ0.TCR.BYTE	= 0x23;					// GRAと一致でクリア&立ち上がりでカウント&プリスケーラ/8に
	TZ0.POCR.BYTE	= 0xF8;					// アクティブ設定
	TZ.TPMR.BYTE	= 0x8E;					// PWMモードに
	TZ.TOCR.BYTE	= 0x0C;					// 初期出力設定
	TZ0.GRA			= 25000;				// MAX=25000
	TZ0.GRC			= 0;
	TZ0.GRD			= 0;

	IENR1.BYTE		= 0x3F;					// 割り込み許可


	MoveStagePlus(-500);


	for(;;){
		if(0 >= pulse && 0 != mode){
			mode = 0;
			TZ.TOER.BIT.EC0 = 1;
			TZ.TOER.BIT.ED0 = 1;
			TZ0.GRC = 0;
			TZ0.GRD = 0;
			TZ.TSTR.BIT.STR0 = 0;
		}
		lcd_xy(1,1);
		lcd_puts("pulse=");
		if(0 > pulse){
			lcd_puts("-");
		}
		lcd_dataout(pulse < 0 ? -pulse : pulse);
		lcd_puts("   ");
		lcd_xy(1,2);
		lcd_puts("mode=");
		lcd_dataout(mode);
		lcd_puts("   ");
	}
}

void WKP_func(){
	// エンコーダ割り込み
	if(1 == IWPR.BIT.IWPF0){
		if(0 == IO.PDR5.BIT.B1){
			pulse--;
			IWPR.BYTE = 0x00;
			return;
		}
		if(1 == IO.PDR5.BIT.B1){
			pulse--;
			IWPR.BYTE = 0x00;
			return;
		}
	}
	// フォトマイクロセンサ1割り込み
	if(1 == IWPR.BIT.IWPF2){
		pulse = 0;							// 回転量初期化
		IWPR.BYTE = 0x00;					// 割り込みフラグクリア
		TZ.TOER.BIT.EC0 = 1;
		TZ.TOER.BIT.ED0 = 1;
		TZ0.GRC = 0;
		TZ0.GRD = 0;
		TZ.TSTR.BIT.STR0 = 0;				// モーター割り込み不可
		return;
	}
	// フォトマイクロセンサ2割り込み
	if(1 == IWPR.BIT.IWPF3){
		pulse = 0;							// 回転量初期化
		IWPR.BYTE = 0x00;					// 割り込みフラグクリア
		TZ.TOER.BIT.EC0 = 1;
		TZ.TOER.BIT.ED0 = 1;
		TZ0.GRC = 0;
		TZ0.GRD = 0;
		TZ.TSTR.BIT.STR0 = 0;				// モーター割り込み不可
		return;
	}
}

void MoveStageL(void){
	mode = 2;
	TZ0.GRC = 0;
	TZ0.GRD = 15000;
	TZ.TOER.BIT.ED0 = 0;
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	IRR1.BYTE = 0x30;
}

void MoveStageR(void){
	mode = 2;
	TZ0.GRC = 15000;
	TZ0.GRD = 0;
	TZ.TOER.BIT.EC0 = 0;
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	IRR1.BYTE = 0x30;
}

void MoveStagePlus(int n){
	if(1 <= n){
		mode = 1;
		pulse = n;
		TZ0.GRC = 15000;
		TZ0.GRD = 0;
		TZ.TOER.BIT.EC0 = 0;
	}
	if(-1 >= n){
		mode = 1;
		pulse = -n;
		TZ0.GRC = 0;
		TZ0.GRD = 15000;
		TZ.TOER.BIT.ED0 = 0;
	}
	TZ0.TCNT = 0;
	TZ.TSTR.BIT.STR0 = 1;
	IRR1.BYTE = 0x30;
}

void wait(){
	unsigned int i;
	for(i = 0; i < 500000; i++){
		;
	}
}

#ifdef __cplusplus
void abort(void)
{

}
#endif
